from __future__ import annotations

import contextlib
import ssl
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from one_ring_loop.log import get_logger

if TYPE_CHECKING:
    from collections.abc import Callable

    from one_ring_loop.streams.protocols import TransportStream
    from one_ring_loop.typedefs import Coro

logger = get_logger()


@dataclass(slots=True, kw_only=True)
class TLSStream:
    """Stream wrapper that encrypts sent/decrypts received data."""

    _transport_stream: TransportStream

    _ssl_object: ssl.SSLObject

    _read_bio: ssl.MemoryBIO

    _write_bio: ssl.MemoryBIO

    _standard_compatible: bool

    _closed: bool = field(default=False)

    def close(self) -> Coro[None]:
        """Closes the TLS resouce."""
        if self._closed:
            return

        if self._standard_compatible:
            with contextlib.suppress(Exception):
                yield from self._call_ssl_method(self._ssl_object.unwrap)
        yield from self._transport_stream.close()
        self._closed = True

    def receive(self, max_bytes: int = 65536) -> Coro[bytes]:
        """Receives bytes from peer.

        Args:
            max_bytes: maximum bytes to receive
        """
        data = yield from self._call_ssl_method(self._ssl_object.read, max_bytes)
        return data

    def send(self, data: bytes) -> Coro[None]:
        """Encrypts and sends data to peer.

        Args:
            data: data to encrypt and send
        """
        yield from self._call_ssl_method(self._ssl_object.write, data)

    @classmethod
    def wrap(
        cls,
        transport_stream: TransportStream[bytes],
        *,
        ssl_context: ssl.SSLContext,
        hostname: str | bytes | None = None,
        server_side: bool = True,
        standard_compatible: bool = True,
    ) -> Coro[TLSStream]:
        """Wraps an existing stream with TLS.

        Args:
            transport_stream: the bytestream to wrap
            ssl_context: ssl context generated by Python's ssl builtin
            hostname: specifies hostname of service connecting to from client side
            server_side: server-side/client-side behaviour
            standard_compatible: if to unwrap (closing handshake) on close
        """
        read_bio = ssl.MemoryBIO()
        write_bio = ssl.MemoryBIO()
        ssl_object = ssl_context.wrap_bio(
            read_bio,
            write_bio,
            server_side=server_side,
            server_hostname=hostname,
        )

        tls_stream = cls(
            _transport_stream=transport_stream,
            _ssl_object=ssl_object,
            _read_bio=read_bio,
            _write_bio=write_bio,
            _standard_compatible=standard_compatible,
        )

        yield from tls_stream._call_ssl_method(ssl_object.do_handshake)

        return tls_stream

    def _call_ssl_method[T, **P](
        self,
        func: Callable[P, T],
        *args: P.args,
        **kwargs: P.kwargs,
    ) -> Coro[T]:
        """Helper to call ssl methods."""
        while True:
            try:
                result = func(*args, **kwargs)
            except ssl.SSLWantReadError:
                if self._write_bio.pending:
                    yield from self._transport_stream.send(self._write_bio.read())
                data = yield from self._transport_stream.receive()
                if not data:
                    self._read_bio.write_eof()
                else:
                    self._read_bio.write(data)
            except ssl.SSLWantWriteError:
                yield from self._transport_stream.send(self._write_bio.read())
            else:
                if self._write_bio.pending:
                    yield from self._transport_stream.send(self._write_bio.read())
                return result
